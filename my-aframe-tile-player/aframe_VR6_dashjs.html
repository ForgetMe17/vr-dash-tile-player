<!DOCTYPE html>

<html lang="en">

    <head>

		<meta charset="utf-8"/>
		<title>(^_^)~ VR PLAYER ~(^_^)</title>
		
		<script src="./dash.js/dist/dash.all.debug.js"></script>
		<script src="opencv.js"></script>
		<script src="HighestBitrateRule.js" class="code"></script>
		<script src="FOVRule.js" class="code"></script>
		<script src="FOVContentRule.js" class="code"></script>

		<script>
			// Global variables
			var players = {};  // Container for players, which is easy for us to operate in them.
			var buffer_empty_flag = {};  // Flags for players, showing whether the player is frozen or not.
			var lon = 90, lat = 0;  // Longitude and latitude in spherical coordinates.
			var pointerX, pointerY;  // Position of mouse click
			var contents = {};  // Contents from JSON file
			var myBufferLength = {};  // Data from monitor
			var myAverageThroughput = {};  // Data from monitor
			var myTime = {};  // Data from monitor
			var myQuality = {};  // Data from monitor
			var results = [];  // Data from contents analytics
		</script>

		<script>
			// Reading json file
			function getContents(url, callback) {
				var xhr = new XMLHttpRequest();
				xhr.open("GET", url, true);
				xhr.onload = callback
				xhr.send();
			}

			// Read json file if json is available
			function openJSON(url) {
				players = {};
				buffer_empty_flag = {};
				lon = 90;
				lat = 0;
				contents = {};
				getContents(url, function() {
					contents = JSON.parse(this.responseText);
					document.getElementById('json').value += " (Loaded!)";
				});
			}

			// Read default json file if json is unavailable, then change the srcs
			function openURLs() {
				contents = {};
				getContents('./default.json', function() {
					contents = JSON.parse(this.responseText);
					let urls = document.getElementById("url").value.split(/[(\n)\n]+/);	
					for (let i = 0; i < contents.face; i++) {
						for (let j = 0; j < contents.row; j++) {
							for (let k = 0; k < contents.col; k++) {
								contents.tiles[i][j][k].src = (i * contents.row * contents.col + j * contents.col + k) < urls.length ? urls[i * contents.row * contents.col + j * contents.col + k] : urls[urls.length - 1];
							}
						}
					}
					document.getElementById('url').value += " (Loaded!)";
				});
			}
		</script>

        <script class="code">
			// Pause in all the players
			function pause_all() {
				let count = 0;
				for (let i = 0; i < contents.face; i++) {
					for (let j = 0; j < contents.row; j++) {
						for (let k = 0; k < contents.col; k++) {
							players[count].pause();
							count++;
							console.log("Player_" + i + "_" + j + "_" + k + " pauses.");
						}
					}
				}
				if (contents.audio && contents.audio != "") {
					players[count].pause();
					console.log("Audio pauses.");
				}
			}

			// Play in all the players
			function play_all() {
				let count = 0;
				for (let i = 0; i < contents.face; i++) {
					for (let j = 0; j < contents.row; j++) {
						for (let k = 0; k < contents.col; k++) {
							players[count].play();
							count++;
							console.log("Player_" + i + "_" + j + "_" + k + " plays.");
						}
					}
				}
				if (contents.audio && contents.audio != "") {
					players[count].play();
					console.log("Audio plays.");
				}
			}

			// Triggered when any player's buffer is empty, which to stop all the players and wait for rebuffering.
			function buffer_empty_event(e) {
				buffer_empty_flag[e.count] = true;
				pause_all();
			}

			// Triggered when any player's buffer is loaded (again), which to start all the players when all-set.
			function buffer_loaded_event(e) {
				if (buffer_empty_flag[e.count] == true) {
					buffer_empty_flag[e.count] = false;

					let count = 0;
					for (let i = 0; i < contents.face; i++) {
						for (let j = 0; j < contents.row; j++) {
							for (let k = 0; k < contents.col; k++) {
								if (buffer_empty_flag[count] == true) {
									return;
								}
								count++;
							}
						}
					}
					if (contents.audio && contents.audio != "") {
						if (buffer_empty_flag[count] == false) {
							play_all();
						}
					} else {
						play_all();
					}
				}
			}

			// Initialize when loading the videos
            function initial() {
				let video, url;
				let count = 0;
                for (let i = 0; i < contents.face; i++) {
					for (let j = 0; j < contents.row; j++) {
						for (let k = 0; k < contents.col; k++) {
							video = document.getElementById( "frame" ).contentWindow.document.querySelector("#" + "video_" + i + "_" + j + "_" + k);
							players[count] = new dashjs.MediaPlayer().create();
							url = contents.baseUrl + contents.tiles[i][j][k].src;
							buffer_empty_flag[count] = true;

							// Don't use dash.js default rules
							players[count].updateSettings({
								'info': {
									'id': "video_" + i + "_" + j + "_" + k,
									'count': count,
									'face': i,
									'row': j,
									'col': k 
								},
								'streaming': {
									'abr': {
										'useDefaultABRRules': false
									}
									// liveDelay: null, 
									// liveCatchup: {
									// 	enabled: true
									// }
								}
							});
							// Add my custom quality switch rule, look at [].js to know more about the structure of a custom rule
							let index = document.getElementById("rule").selectedIndex;
							let selectedRule = document.getElementById("rule").options[index].text;
							switch (selectedRule) {
								case "FOVRule":
									players[count].addABRCustomRule('qualitySwitchRules', 'FOVRule', FOVRule);
									break;
								case "HighestBitrateRule":
									players[count].addABRCustomRule('qualitySwitchRules', 'HighestBitrateRule', HighestBitrateRule);
									break;
								case "FOVContentRule":
									players[count].addABRCustomRule('qualitySwitchRules', 'FOVContentRule', FOVContentRule);
									break;									
								default:
									players[count].addABRCustomRule('qualitySwitchRules', 'FOVRule', FOVRule);
									break;
							}

							// Turn on the event listeners and add actions for triggers 
							players[count].on(dashjs.MediaPlayer.events["BUFFER_EMPTY"],buffer_empty_event);
							players[count].on(dashjs.MediaPlayer.events["BUFFER_LOADED"],buffer_loaded_event);

							// Initializing
							players[count].initialize(video, url, false);
							myBufferLength[count] = players[count].getBufferLength();;
							myAverageThroughput[count] = players[count].getAverageThroughput("video");
							myTime[count] = players[count].time();
							myQuality[count] = players[count].getQualityFor("video");

							// Get video captures
							let canvas = document.createElement( "canvas" );
							canvas.id = "capture_" + i + "_" + j + "_" + k;
							canvas.width = 256;
    						canvas.height = 256;
							document.getElementById("captures").appendChild(canvas);
							
							count++;
						}
					}
				}
				// Audio part
				if (contents.audio && contents.audio != "") {
					var audio = document.getElementById( "frame" ).contentWindow.document.querySelector("#audio");
					players[count] = new dashjs.MediaPlayer().create();
					url = contents.baseUrl + contents.audio;
					buffer_empty_flag[count] = true;

					players[count].updateSettings({
						'info': {
							'id': "audio",
							'count': count,
						}
					});

					// Turn on the event listeners and add actions for triggers 
					players[count].on(dashjs.MediaPlayer.events["BUFFER_EMPTY"],buffer_empty_event);
					players[count].on(dashjs.MediaPlayer.events["BUFFER_LOADED"],buffer_loaded_event);

					// Initializing
					players[count].initialize(audio, url, false);
					myBufferLength[count] = players[count].getBufferLength();;
					myAverageThroughput[count] = players[count].getAverageThroughput("video");  //////////////////////////
					myTime[count] = players[count].time();
					myQuality[count] = players[count].getQualityFor("video");  //////////////////////////
				}
				setInterval(updateStats, 500);
				setInterval(function () {
					for (let i = 0; i < contents.face; i++) {
						for (let j = 0; j < contents.row; j++) {
							for (let k = 0; k < contents.col; k++) {
								document.getElementById("capture_" + i + "_" + j + "_" + k).getContext('2d').drawImage(document.getElementById( "frame" ).contentWindow.document.querySelector("#" + "video_" + i + "_" + j + "_" + k), 0, 0, 256, 256);
								// img.src = canvas.toDataURL("image/png");
							}
						}
					}
				}, 2000);
			}
			
			// Show the data in monitor
			function updateStats() {
				document.querySelector("#stats").innerHTML = "Monitor:<br>";
				for (let i = 0; i < contents.face; i++) {
					for (let j = 0; j < contents.row; j++) {
						for (let k = 0; k < contents.col; k++) {
							myBufferLength[i * contents.row * contents.col + j * contents.col + k] = players[i * contents.row * contents.col + j * contents.col + k].getBufferLength();;
							myAverageThroughput[i * contents.row * contents.col + j * contents.col + k] = players[i * contents.row * contents.col + j * contents.col + k].getAverageThroughput("video");
							myTime[i * contents.row * contents.col + j * contents.col + k] = players[i * contents.row * contents.col + j * contents.col + k].time();
							myQuality[i * contents.row * contents.col + j * contents.col + k] = players[i * contents.row * contents.col + j * contents.col + k].getQualityFor("video");							
							document.querySelector("#stats").innerHTML += ( "Video_" + i + "_" + j + "_" + k + ":<br>" );
							document.querySelector("#stats").innerHTML += "Buffer level ";
							document.querySelector("#stats").innerHTML += myBufferLength[i * contents.row * contents.col + j * contents.col + k];
							document.querySelector("#stats").innerHTML += " s<br>";
							document.querySelector("#stats").innerHTML += "Average Throughput ";
							document.querySelector("#stats").innerHTML += myAverageThroughput[i * contents.row * contents.col + j * contents.col + k];
							document.querySelector("#stats").innerHTML += " bps<br>";
							document.querySelector("#stats").innerHTML += "Time ";
							document.querySelector("#stats").innerHTML += myTime[i * contents.row * contents.col + j * contents.col + k];
							document.querySelector("#stats").innerHTML += " s<br>";
							document.querySelector("#stats").innerHTML += "Quality ";
							document.querySelector("#stats").innerHTML += myQuality[i * contents.row * contents.col + j * contents.col + k];
							document.querySelector("#stats").innerHTML += "<br><br>";
						}
					}
				}
				if (contents.audio && contents.audio != "") {
					myBufferLength[contents.face * contents.row * contents.col] = players[contents.face * contents.row * contents.col].getBufferLength();;
					myAverageThroughput[contents.face * contents.row * contents.col] = players[contents.face * contents.row * contents.col].getAverageThroughput("video");  //////////////////////////
					myTime[contents.face * contents.row * contents.col] = players[contents.face * contents.row * contents.col].time();
					myQuality[contents.face * contents.row * contents.col] = players[contents.face * contents.row * contents.col].getQualityFor("video");  //////////////////////////
					document.querySelector("#stats").innerHTML += ( "Audio:<br>" );
					document.querySelector("#stats").innerHTML += "Buffer level ";
					document.querySelector("#stats").innerHTML += myBufferLength[contents.face * contents.row * contents.col];
					document.querySelector("#stats").innerHTML += " s<br>";
					document.querySelector("#stats").innerHTML += "Average Throughput ";
					document.querySelector("#stats").innerHTML += myAverageThroughput[contents.face * contents.row * contents.col];
					document.querySelector("#stats").innerHTML += " bps<br>";
					document.querySelector("#stats").innerHTML += "Time ";
					document.querySelector("#stats").innerHTML += myTime[contents.face * contents.row * contents.col];
					document.querySelector("#stats").innerHTML += " s<br>";
					document.querySelector("#stats").innerHTML += "Quality ";
					document.querySelector("#stats").innerHTML += myQuality[contents.face * contents.row * contents.col];
					document.querySelector("#stats").innerHTML += "<br><br>";
				}
			}
		</script>

		<script>
			// Open the iframe according to the number of faces, rows and cols
			function aframe_init() {
				if (contents == {}) {
					return;
				}
				document.getElementById( 'frame' ).src = "./" + contents.face + "_" + contents.row + "_" + contents.col + ".html";
				lon = 90;
				lat = 0;
			}
			// Switch the source automatically according to the situation
			function VOD_LIVE() {
				let index = document.getElementById("type").selectedIndex;
				let selectedRule = document.getElementById("type").options[index].text;
				switch (selectedRule) {
					case "VOD":
						document.getElementById("json").value = "http://localhost/CMPVP907/aframeVP907.json";
						break;
					case "LIVE":
						document.getElementById("json").value = "http://222.20.77.111/dash/default.json";
						break;
					default:
						document.getElementById("json").value = "";
						break;
				}
			}
		</script>

		<style>
			body {
				background-color: #ffffff;
			}
		</style>
		
	</head>
	
    <body>

		<iframe id="frame" width="1000" height="500"></iframe>

		<div style="z-index: 999; height: 22px; width: 500px;">
			<button id="Link" onclick="document.getElementById('json').value != '' ? openJSON(document.getElementById('json').value) : openURLs();">Link</button>
			<button id="aframe_init" onclick="aframe_init();">Frame</button>
			<button id="Load" onclick="initial();">Load</button>
			<button id="Play" onclick="play_all();">Play</button>
			<button id="Pause" onclick="pause_all();">Pause</button>
		</div>
		
		<div style="z-index: 999; color: #000000; height: 250px;">
			<br>JSON(Empty then use the URLs below):<br>
			<textarea id="json" rows="1" cols="100">http://localhost/CMPVP907/aframeVP907.json</textarea>			
			<br>URL(Used when JSON is empty):<br>
			<textarea id="url" rows="6" cols="100"></textarea>
			<br>
			<select id="type" onchange="VOD_LIVE();">
				<option value ="VOD">VOD</option>
				<option value ="LIVE">LIVE</option>
			</select>
			<select id="rule">
				<option value ="FOVRule">FOVRule</option>
				<option value ="HighestBitrateRule">HighestBitrateRule</option>
				<option value ="FOVContentRule">FOVContentRule</option>
			</select>
			<br>
			<span id="stats" style="width: 500px; height: 1000px; position: fixed; top: 10px; right: 10px; background-color: whitesmoke;">Monitor Loaded.</span>
		</div>

		<div id="captures" style="width: 768px;"></div>
		
		<input id="result_input" type="file" onchange="csv2json(this)">

		<script>
			// Translate the csv file loaded manually to json data
			function csv2json(input) {
				let file = input.files[0];	// Load the file
				let reader = new FileReader();	// Create a new FileReader instance
				reader.readAsText(file);	// Read the CSV file
				reader.onload = () => {		// Trigger when loaded
					let fileData = reader.result	// Read the data
					let lines = fileData.split("\n");
					let result = [];
					let headers = lines[0].split(",");
					for(let i = 1; i < lines.length; i++) {
						let obj = {};
						let currentline = lines[i].split(",");
						for(var j = 0; j < headers.length ; j++) {
							obj[headers[j]] = currentline[j];
						}
						result.push(obj);
					}
					results.push(result);
				}
			}
		</script>
		
		<script>
			
			// Enable the FOV event listener in iframe
			document.getElementById('frame').onload = function () {
				document.getElementById('frame').contentDocument.addEventListener( 'pointerdown', onPointerDown );
			}

            function onPointerDown( event ) {
				if ( event.isPrimary === false ) return;
				pointerX = event.clientX;
				pointerY = event.clientY;
				document.getElementById('frame').contentDocument.addEventListener( 'pointermove', onPointerMove );
				document.getElementById('frame').contentDocument.addEventListener( 'pointerup', onPointerUp );
				console.log("Pointer downs. lon: "+ lon + "; lat: " + lat + ".");
			}

			function onPointerMove( event ) {
				if ( event.isPrimary === false ) return;
				lon += ( event.clientX - pointerX ) * 0.1148;  // In Chrome, turn right then the lon increases.
				lon > 360 ? lon = lon - 360 : null;
				lon < 0 ? lon = lon + 360 : null;
				lat -= ( event.clientY - pointerY ) * 0.1148;  // In Chrome, turn up then the lat increases.
				lat > 90 ? lat = 90 : null;
				lat < -90 ? lat = -90 : null;
				pointerX = event.clientX;
				pointerY = event.clientY;
				console.log("Pointer moves. lon: "+ lon + "; lat: " + lat + ".");
			}

			function onPointerUp() {
				if ( event.isPrimary === false ) return;
				document.getElementById('frame').contentDocument.removeEventListener( 'pointermove', onPointerMove );
				document.getElementById('frame').contentDocument.removeEventListener( 'pointerup', onPointerUp );
				console.log("Pointer ups. lon: "+ lon + "; lat: " + lat + ".");
			}

		</script>
        
	</body>
	
</html>